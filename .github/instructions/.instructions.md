# Seven Pillars Enforcement: RylanLabs Developer Instructions

**Guardian**: Carter | **Auditor**: Bauer | **Security**: Beale | **Maturity**: v1.1.0

This document details how the Seven Pillars are enforced through the Trinity pattern and agentic code generation.

---

## Seven Pillars Overview

### 1. Idempotency

**Definition**: Operations produce the same result regardless of how many times they execute.

**Why It Matters**: Prevents cascading failures when scripts/commands are retried; enables safe automation and recovery.

**Trinity Role**: Carter enforces idempotency patterns in code reviews and agent specs.

**Implementation**:

```bash
# ✅ CORRECT - Idempotent
if [[ ! -L "$symlink" ]]; then
    ln -s "$target" "$symlink"
fi

# ❌ INCORRECT - Creates error on second run
ln -s "$target" "$symlink"
```

```python
# ✅ CORRECT - Check before creating
if not os.path.exists(config_file):
    with open(config_file, 'w') as f:
        json.dump(defaults, f)

# ❌ INCORRECT - Fails if file exists
with open(config_file, 'w') as f:
    json.dump(defaults, f)
```

**Validation Command**:

```bash
# Run operation twice, verify same result both times
./script.sh
./script.sh
# Check outputs are identical
```

---

### 2. Error Handling

**Definition**: Failures are detected immediately and handled gracefully.

**Why It Matters**: Prevents silent failures; enables clear debugging; supports human intervention gates.

**Trinity Role**: Bauer validates error handling through testing and audit logs.

**Implementation**:

```bash
# ✅ CORRECT - Explicit error checking
set -euo pipefail
trap 'log_error "Script failed at line $LINENO"' ERR

result=$(command_that_might_fail) || {
    log_error "Command failed with exit code $?"
    return 1
}

# ❌ INCORRECT - Silent failures
set +e
result=$(command_that_might_fail)
echo "$result"  # May be empty or error message
```

```python
# ✅ CORRECT - Specific exception handling
try:
    data = json.load(config_file)
except FileNotFoundError as e:
    logger.error(f"Config missing: {config_file}")
    sys.exit(1)
except json.JSONDecodeError as e:
    logger.error(f"Invalid JSON in {config_file}: {e}")
    sys.exit(1)

# ❌ INCORRECT - Bare except
try:
    data = json.load(config_file)
except:
    pass  # Silent failure
```

**Validation Command**:

```bash
# Test error paths explicitly
./script.sh --invalid-arg  # Should fail with clear message
echo "Exit code: $?"        # Should be non-zero
```

---

### 3. Functionality

**Definition**: Code does what it claims; behavior matches documentation.

**Why It Matters**: Ensures specifications are met; enables testing and validation; documents intent.

**Trinity Role**: Carter specifies expected behavior; Bauer validates through testing.

**Implementation**:

```python
def process_records(records: list[dict]) -> int:
    """Process records and return count processed.

    This function MUST:
    1. Validate each record against schema
    2. Skip invalid records with error logging
    3. Return count of successfully processed records

    Args:
        records: List of record dicts.

    Returns:
        Count of successfully processed records.
    """
    count = 0
    for record in records:
        if validate_record(record):
            process_one(record)
            count += 1
        else:
            logger.error(f"Invalid record: {record}")

    return count
```

**Validation Checklist**:

- [ ] Docstring accurately describes behavior
- [ ] Return type matches documentation
- [ ] All parameters used as documented
- [ ] Error cases handled as described

---

### 4. Audit Logging

**Definition**: All significant actions are recorded for debugging, compliance, and monitoring.

**Why It Matters**: Enables debugging production issues; satisfies compliance requirements; supports failure analysis.

**Trinity Role**: Bauer enforces structured logging; Beale monitors for security events.

**Implementation**:

```bash
# ✅ CORRECT - Structured logging
log_info() {
    local msg="$1"
    local timestamp=$(date -Iseconds)
    echo "{\"timestamp\": \"$timestamp\", \"level\": \"INFO\", \"message\": \"$msg\"}" >&2
    logger -t bootstrap "$msg"
}

log_info "Starting bootstrap in $(pwd)"
create_symlink "$source" "$target"
log_info "Bootstrap completed successfully"

# ❌ INCORRECT - No audit trail
echo "Starting..."
create_symlink "$source" "$target"
echo "Done"
```

```python
# ✅ CORRECT - Structured logging with context
import logging

logger = logging.getLogger(__name__)

def process_payment(invoice_id: str, amount: float) -> bool:
    """Process payment for invoice."""
    logger.info("Processing payment", extra={
        'invoice_id': invoice_id,
        'amount': amount,
        'timestamp': datetime.utcnow().isoformat()
    })

    try:
        result = gateway.charge(amount, invoice_id)
        logger.info("Payment successful", extra={'invoice_id': invoice_id, 'result': result})
        return True
    except PaymentError as e:
        logger.error("Payment failed", exc_info=True, extra={
            'invoice_id': invoice_id,
            'error': str(e)
        })
        return False
```

**Validation Command**:

```bash
# Verify audit logs contain required information
grep "bootstrap" /var/log/syslog  # Or query structured logs
# Should include: timestamp, operation, status, context
```

---

### 5. Failure Recovery

**Definition**: System recovers gracefully from failures; no permanent data loss.

**Why It Matters**: Enables safe automation; prevents catastrophic cascading failures; supports rollback.

**Trinity Role**: Bauer tests recovery paths; Beale ensures security during recovery.

**Implementation**:

```bash
# ✅ CORRECT - Backup and recovery
BACKUP_DIR="/tmp/bootstrap_backup_$$"

trap 'cleanup_and_recover' EXIT ERR

cleanup_and_recover() {
    local exit_code=$?
    if [[ $exit_code -ne 0 ]] && [[ -d "$BACKUP_DIR" ]]; then
        log_info "Recovering from backup..."
        restore_from_backup "$BACKUP_DIR"
    fi
    rm -rf "$BACKUP_DIR"
    return $exit_code
}

# Create backup before mutation
mkdir -p "$BACKUP_DIR"
cp -r ./configs "$BACKUP_DIR/"

# Perform operation
update_configs ./configs

# If we reach here, cleanup succeeds without recovery

# ❌ INCORRECT - No recovery capability
rm -rf ./configs
update_configs ./configs
# If script fails, configs are lost permanently
```

**Validation Command**:

```bash
# Test failure recovery
./script.sh --simulate-failure
# Verify original state is restored
ls -la ./configs  # Should exist and be intact
```

---

### 6. Security Hardening

**Definition**: Code resists attacks; no secrets are exposed; minimal privilege elevation.

**Why It Matters**: Prevents data breaches; satisfies compliance; protects users.

**Trinity Role**: Beale leads security reviews; ensures scanning tools catch vulnerabilities.

**Implementation**:

```bash
# ✅ CORRECT - No hardcoded secrets, proper permissions
#!/usr/bin/env bash

# Never hardcode secrets
API_KEY="${API_KEY:-}"
if [[ -z "$API_KEY" ]]; then
    echo "ERROR: API_KEY environment variable not set" >&2
    exit 1
fi

# Minimal privilege: don't elevate unless necessary
# Run as regular user, not sudo

# Quote all variables to prevent injection
curl -s -H "Authorization: Bearer $API_KEY" "$endpoint"

# ❌ INCORRECT - Security violations
#!/usr/bin/env bash

# Hardcoded secret (NEVER DO THIS)
API_KEY="sk_live_51234567890"

# Unnecessary sudo
sudo curl -s -H "Authorization: Bearer $API_KEY" "$endpoint"

# Unquoted variable - injection vulnerability
curl -s -H "Authorization: Bearer $API_KEY" $endpoint
```

```python
# ✅ CORRECT - No shell injection, input validation
import subprocess
import shlex

def backup_database(db_name: str) -> bool:
    """Backup database safely."""
    # Validate input
    if not re.match(r'^[a-z_][a-z0-9_]*$', db_name):
        logger.error(f"Invalid db name: {db_name}")
        return False

    # Use list args, no shell (S603 remediation)
    cmd = ['pg_dump', db_name]
    result = subprocess.run(cmd, capture_output=True, check=False)

    if result.returncode != 0:
        logger.error(f"Backup failed: {result.stderr.decode()}")
        return False

    return True

# ❌ INCORRECT - Shell injection vulnerability (S603)
def backup_database(db_name: str) -> bool:
    cmd = f"pg_dump {db_name}"
    result = subprocess.run(cmd, shell=True)  # Vulnerable!
    return result.returncode == 0
```

**Validation Command**:

```bash
# Run security scanners
bandit -r linting/          # Python security
shellcheck scripts/*.sh     # Bash security
git-secrets --scan          # Check for secrets
```

---

### 7. Documentation

**Definition**: Code is understandable; maintainers know intent and constraints.

**Why It Matters**: Enables knowledge transfer; reduces onboarding time; prevents regressions.

**Trinity Role**: Carter specifies documentation standards; Bauer verifies coverage.

**Implementation**:

```python
# ✅ CORRECT - Complete documentation

def calculate_discount(amount: float, tier: str) -> float:
    """Calculate discount percentage for customer tier.

    Applies tiered discounts based on customer classification:
    - Silver: 5% discount
    - Gold: 10% discount
    - Platinum: 15% discount

    Args:
        amount: Purchase amount in USD.
        tier: Customer tier ('silver', 'gold', 'platinum').

    Returns:
        Discount percentage (0-15).

    Raises:
        ValueError: If tier not recognized.

    Examples:
        >>> calculate_discount(100, 'gold')
        10.0
        >>> calculate_discount(100, 'invalid')
        ValueError: Unknown tier: invalid
    """
    discounts = {'silver': 5.0, 'gold': 10.0, 'platinum': 15.0}

    if tier not in discounts:
        raise ValueError(f"Unknown tier: {tier}")

    return discounts[tier]

# ❌ INCORRECT - No documentation
def calculate_discount(amount, tier):
    d = {'silver': 5, 'gold': 10, 'platinum': 15}
    return d.get(tier, 0)
```

**Documentation Checklist**:

- [ ] Function/class docstring present (Google style)
- [ ] Parameters documented with types
- [ ] Return value documented
- [ ] Exceptions documented
- [ ] Usage examples provided
- [ ] README present with setup instructions
- [ ] CHANGELOG updated with version history

---

## Trinity Pattern

### Carter: Identity & Standards

**Responsibility**: Define and enforce coding standards.

**In Code Reviews**:

- Verify compliance with `.agent.md` rules
- Check for prohibited patterns
- Approve architectural decisions

**Example Issues**:

- "Docstring missing: Please add Google-style docstring"
- "SC2086: Quote variable expansion `$var` → `"$var"`"
- "MD040: Specify language for code fence (use ```python)"

**Escalation**: Block merge if critical violations.

---

### Bauer: Audit & Validation

**Responsibility**: Verify code meets specifications through testing.

**In CI Pipeline**:

- Run linters (ruff, shellcheck, markdownlint, yamllint)
- Execute test suite
- Check coverage thresholds
- Validate against schemas

**Example Issues**:

- "ruff: D101 Missing docstring in public module"
- "shellcheck: SC2181 Check exit code on failure"
- "pytest: Test coverage 65% (target 70%)"

**Escalation**: Block merge if validation fails.

---

### Beale: Security & Hardening

**Responsibility**: Mitigate security risks.

**In Security Review**:

- Run Bandit (Python security)
- Check for hardcoded secrets
- Validate input sanitization
- Review privilege escalation

**Example Issues**:

- "Bandit S603: Use of `shell=True` is risky"
- "Hardcoded credentials found: API_KEY"
- "Unquoted variable expansion: `$user_input`"

**Escalation**: Block merge immediately on security violation.

---

## Prohibited Patterns

### ❌ No `git commit --no-verify`

**Why**: Bypasses pre-commit hooks; allows non-compliant code.

```bash
# ❌ PROHIBITED
git commit --no-verify -m "Quick fix"

# ✅ CORRECT - Fix violations first
pre-commit run --all-files
git commit -m "fix: resolve linting violations"
```

---

### ❌ No Hardcoded Secrets

**Includes**: Passwords, API keys, tokens, database credentials, private IPs.

```bash
# ❌ PROHIBITED
API_KEY="sk_live_51234567890"
DATABASE_PASSWORD="super_secret_123"

# ✅ CORRECT
API_KEY="${API_KEY:-}"
if [[ -z "$API_KEY" ]]; then
    echo "ERROR: API_KEY environment variable required" >&2
    exit 1
fi
```

---

### ❌ No `rm -rf` Without Confirmation

**Why**: Irreversible data loss if path is wrong.

```bash
# ❌ PROHIBITED
rm -rf /var/log/$service_name/*

# ✅ CORRECT - Interactive prompt
rm -ri /var/log/$service_name/

# ✅ CORRECT - Explicit confirmation
if [[ "${FORCE_DELETE:-false}" != "true" ]]; then
    echo "Would delete: /var/log/$service_name/*"
    echo "Run with FORCE_DELETE=true to confirm"
    exit 0
fi
rm -rf /var/log/$service_name/*
```

---

### ❌ No "Consciousness" Counters

**Why**: Terminology bleed from previous repo; use Maturity instead.

```yaml
# ❌ PROHIBITED
consciousness: 9.9

# ✅ CORRECT
maturity: v1.1.0
```

---

## Override Protocol

**When to Override**: In rare cases where standards conflict with legacy requirements or platform constraints.

**Process**:

1. Add comment explaining override:

```python
# agent-override: Legacy API requires non-standard error handling
# Reference: Ticket #1234 (API v0.9.0 compatibility)
# Planned removal: When v2.0.0 released
def process_legacy_api():  # noqa: D100
    pass
```

2. Link to related issue/ticket
3. Plan removal date
4. Get approval from Carter (standards guardian)

**Requirements**:

- Comment must be clear and specific
- Reference external ticket/issue
- Don't leave permanent overrides

---

## Pre-Commit Validation Checklist

**Before Committing**:

- [ ] Run `pre-commit run --all-files`
- [ ] Fix violations (or document overrides)
- [ ] Run `make ci-local` (if available)
- [ ] Verify tests pass: `pytest` or `./test.sh`
- [ ] Check linters pass:
  - `markdownlint docs/ agents/ instructions/`
  - `shellcheck scripts/*.sh`
  - `ruff check . --fix`
  - `mypy --strict linting/`
  - `yamllint -c .yamllint .`

---

## Pre-Push Validation Checklist

**Before Pushing**:

- [ ] All pre-commit checks pass
- [ ] New code has tests (70%+ coverage target)
- [ ] Documentation updated (README, CHANGELOG, docstrings)
- [ ] Commit message follows format: `<type>(<scope>): <subject>`
- [ ] No debugging code left (print statements, breakpoints)
- [ ] No temporary files committed

---

## Pre-Merge Validation Checklist

**PR Requirements** (code review gate):

- [ ] Passes all CI checks
- [ ] Reviewed by Carter (standards)
- [ ] Reviewed by Bauer (functionality) if logic changes
- [ ] Reviewed by Beale (security) if security-relevant
- [ ] Tests added for new functionality
- [ ] Documentation updated
- [ ] Zero security findings

---

## Hellodeolu v6 Compliance

### RTO <15 Minutes

**Recovery Time Objective**: System recovers from failure <15 min.

**Implementation**:

- Scripts are idempotent (can retry quickly)
- Failures are logged with context
- Recovery instructions are documented
- Backups are available for rollback

---

### Junior-Deployable

**Definition**: A junior developer can safely run operations without senior guidance.

**Implementation**:

- Clear documentation (README, INTEGRATION_GUIDE, inline comments)
- Helpful error messages with context
- Safe defaults (no `rm -rf` without confirmation)
- Dry-run modes for validation

---

### Human --confirm Gates

**Definition**: Critical operations require human confirmation before executing.

**Implementation**:

```bash
# ✅ CORRECT - Confirmation gate
if [[ "${FORCE_DELETE:-false}" != "true" ]]; then
    echo "This will delete: $target_directory"
    echo "To proceed, run: FORCE_DELETE=true $0"
    exit 0
fi

rm -rf "$target_directory"
```

```python
# ✅ CORRECT - Human confirmation
if not args.confirm:
    print(f"This will deploy to: {args.environment}")
    print("To proceed, run with --confirm flag")
    sys.exit(0)

deploy(args.environment)
```

---

## Maturity Version Management

**Semantic Versioning**: MAJOR.MINOR.PATCH

- **MAJOR**: Breaking changes (API modifications)
- **MINOR**: New features, backward compatible
- **PATCH**: Bug fixes, non-breaking updates

**Example Progression**:

- v1.0.0: Initial release (baseline)
- v1.0.1: Bug fix, linting rule update
- v1.1.0: New language overlay, new tool integration
- v2.0.0: Breaking change (new Seven Pillars interpretation)

**Update Process**:

1. Make changes in feature branch
2. Update version in relevant files
3. Add entry to CHANGELOG
4. Create PR for review
5. Merge and tag release

---

**Guardian**: Carter | **Auditor**: Bauer | **Security**: Beale | **Maturity**: v1.1.0
